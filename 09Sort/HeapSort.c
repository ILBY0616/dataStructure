#include <stdio.h>

// 调整大根堆
void adjustHeap(int* data, int root, int length)
{
    data[0] = data[root];
    for (int i = root * 2; i <= length; i *= 2)
    {
        if (i < length && data[i] < data[i + 1])
        {
            i++;
        }
        if (data[0] >= data[i])
        {
            break;
        }
        data[root] = data[i];
        root = i;
    }
    data[root] = data[0];
}

// 建造大根堆
void buildHeap(int* data, int length)
{
    for (int i = length / 2; i >= 1; i--)
    {
        adjustHeap(data, i, length);
    }
}

// 堆排序
void heapSort(int* data, int length, int sortSum)
{
    buildHeap(data, length);
    for (int i = length; i > 1 + length - sortSum; i--)
    {
        data[0] = data[1];
        data[1] = data[i];
        data[i] = data[0];
        adjustHeap(data, 1, i - 1);
    }
}

// 打印序列
void printData(int* data, int length)
{
    for (int i = 1; i <= length; i++)
    {
        printf("%d ", data[i]);
    }
}

// 1. 建立大根堆
// 首先，将待排序数组转换为大根堆，确保每个父节点大于或等于其子节点。对于大根堆，最大元素在堆的根结点。
// 2. 堆排序过程
// 通过以下步骤完成排序：
// 将堆的根节点与堆的最后一个元素交换，并将堆的大小减1。
// 对新的根节点进行调整，使其重新满足大根堆的性质。
// 重复上述步骤，直到堆的大小为1。
// 3. 插入与删除
// 插入：插入堆尾，调整
// 删除：根尾互换，调整
// 根次大值一定在根下层

// 排序思想：
// 堆排序是一种基于堆数据结构的排序算法。堆是一种完全二叉树，满足堆的性质（大根堆：父节点大于或等于子节点）。
// 堆排序的核心思想是通过调整堆，使堆顶元素始终为最大元素。首先建立一个大根堆，然后将堆顶元素与堆的最后一个元素交换位置，
// 使得堆的最大元素进入已排序部分。接着对剩下的元素重新调整堆，重复这一过程直到堆中只剩下一个元素。堆排序的时间复杂度为 O(nlog_2^n)，
// 比快速排序的最坏情况 O(n^2) 更稳定，适合处理大数据。
// 排序操作：
// 1. 排序趟数：堆排序需要进行 n-1 趟排序，首先构建大根堆，接着将堆顶元素交换到数组末尾并调整堆。
// 2. 比较次数：每次调整堆时，需要比较父节点与其子节点，总的比较次数约为 O(nlog_2^n)，每次调整堆的时间复杂度为 O(log_2^n)。
// 3. 移动次数：每次交换堆顶元素与最后一个元素时，涉及两个元素的移动。总的移动次数较少，主要集中在交换操作中。
// 4. 交换次数：每次堆顶元素与最后一个元素交换，通常在每一趟排序中都进行一次交换，总的交换次数为 O(n)。

int main()
{
    int data[101] = {
        101, 100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77,
        76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52,
        51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27,
        26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
    };
    int length = 100, sortSum = 100;
    heapSort(data, length, sortSum);
    printData(data, length);
    return 0;
}
